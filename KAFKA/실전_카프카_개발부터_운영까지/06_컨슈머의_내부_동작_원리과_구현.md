# 6.1 컨슈머 오프셋 관리

컨슈머의 동작 중 가장 핵심은 오프셋 관리입니다. 컨슈머가 문제가 발생하여 새로운 컨슈머가 역할을 대신하는 경우에는 기존 컨슈머의 마지막 메시지 위치부터 새로운 컨슈머가 메시지를 가져올 수 있어야만 장애로부터 빠르게 복구될 수 있습니다. 카프카에서는 메시지의 위치를 오프셋이라고 부르는데 이 오프셋은 숫자 형태로 나타납니다. 컨슈머 그룹은 자신의 오프셋 정보를 카프카에서 가장 안전한 저장소인 토픽에 저장합니다. 즉 `__consumer_offsets` 토픽에 각 컨슈머 그룹별로 오프셋 위치 정보가 기록됩니다.

컨슈머들은 지정된 토픽의 메시지를 읽은 뒤, 읽어온 위치의 오프셋 정보를 `__consumer_offsets`에 기록합니다. 이 때 컨슈머 그룹은 컨슈머 그룹, 토픽, 파티션 등의 내용을 통합해 기록합니다. 여기서 저장되는 오프셋값은 컨슈머가 마지막까지 읽은 위치가 아니라 컨슈머가 다음으로 읽어야 할 위치를 말합니다. 

`__consumer_offsets` 토픽은 다음과 같은 파티션 수와 리플리케이션 팩터 수를 갖고 있으며, server.properties에서 관리자가 원하는 값으로 변경할 수 있습니다.

* offsets.topic.num.partitions : 기본값 50
* offsets.topic.replication.factor : 기본값 3



# 6.2 그룹 코디네이터

컨슈머들은 하나의 컨슈머 그룹의 구성원으로 속하며, 그룹 내 컨슈머들은 서로 자신의 정보를 공유하며 하나의 공동체로 동작합니다. 컨슈머 그룹에서 각 컨슈머에게 작업을 균등하게 분배하는 동작을 컨슈머 리밸런싱이라고 부릅니다.

안정적인 컨슈머 그룹 관리를 위해 그룹 코디네이터가 존재합니다. 

그룹 코디네이터의 목적은 컨슈머 그룹이 구독한 토픽의 파티션들과 그룹의 멤버들을 트랙킹하는 것입니다. 따라서 파티션 또는 구룹의 멤버에 변화가 생기면, 작업을 균등하게 재분배하기 위해 컨슈머 리밸런싱 동작이 발생합니다. 그룹 코디네이터는 각 컨슈머 그룹별로 존재하며, 이러한 그룹 코디네이터는 카프카 클러스터 내의 브로커 중 하나에 위치합니다.



### 그룹 코디네이터와 컨슈머의 동작

1. 컨슈머는 컨슈머 설정값 중에서 bootstrap.brokers 리스트에 있는 브로커에게 컨슈머 클라이언트와 초기 커넥션을 연결하기 위한 요청을 보냅니다.
2. 해당 요청을 받은 브로커는 그룹 코디네이터를 생성하고 컨슈머에게 응답을 보냅니다. 컨슈머 그룹의 첫 번째 컨슈머가 등록될 때까지 아무 작업도 일어나지 않습니다.
3. 그룹 코디네이터는 group.initial.rebalance.delay.ms의 시간 동안 컨슈머의 요청을 기다립니다.
4. 컨슈머는 컨슈머 등록 요청을 그룹 코디네이터에게 보냅니다. 이 때 가장 먼저 요청을 보내는 컨슈머가 컨슈머 그룹의 리더가 됩니다.
5. 컨슈머 등록 요청을 받은 그룹 코디네이터는 해당 컨슈머 그룹이 구독하는 토픽 파티션 리스트 등 리더 컨슈머의 요청에 응답을 보냅니다.
6. 리더 컨슈머는 정해진 컨슈머 파티션 할당 전략에 따라 그룹 내 컨슈머들에게 파티션을 할당한 뒤 그룹 코디네이터에게 전달합니다.
7. 그룹 코디네이터는 해당 정보를 캐시하고 각 그룹 내 컨슈머들에게 성공을 알립니다.
8. 각 컨슈머들은 각자 지정된 토픽 파티션으로부터 메시지들을 가져옵니다.



컨슈머들은 현재 자신들이 속한 컨슈머 그룹에서 빠져나갈 수도 새롭게 합류할 수도 있습니다. 이러한 컨슈머 그룹의 변화들은 컨슈머 코디네이터에게 컨슈머가 join 또는 leave 요청을 보냄으로써 자연스럽게 처리됩니다. 

하지만 컨슈머가 장애로 leave 요청을 보내지 못하고 종료되는 경우 그룹 코디네이터는 어떻게 이를 감지할 수 있을까요?

컨슈머들의 변경을 감지하기 위해 그룹 코디네이터와 컨슈머들은 서로 하트비트를 주고 받습니다. 이렇게 하트비트를 주기적으로 주고받으면서 그룹 코디네이터는 컨슈머가 살아 있는지 잘 동작하는지 확인합니다. 

컨슈머 하트비트 옵션은 아래와 같습니다.

| 컨슈머 옵션           | 값     | 설명                                                         |
| --------------------- | ------ | ------------------------------------------------------------ |
| heartbeat.interval.ms | 3000   | 그룹 코디네이터와 하트비트 인터벌 시간입니다. 해당 시간은 session.timeout.ms보다 낮게 설정해야 하며 3분의 1 수준이 적절합니다. |
| session.timeout.ms    | 10000  | 어떤 컨슈머가 특정 시간 안에 하트비트를 받지 못하면 문제가 발생했다고 판단해 컨슈머 그룹에서 해당 컨슈머는 제거되고 리밸런싱 동작이 일어납니다. |
| max.poll.interval.ms  | 300000 | 컨슈머는 주기적으로 poll()을 호출해 토픽으로부터 레코드들을 가져오는데, poll() 호출 후 최대 5분간 poll() 호출이 없다면 컨슈머가 문제가 있는 것으로 판단해 리밸런싱이 일어납니다. |

> interval : 간격



컨슈머 리밸런싱 동작은 경우에 따라 매우 높은 비용이 지출되므로 가급적 리밸런싱이 자주 발생하지 않도록 주의해야 합니다. 옵션값들을 변경해 그룹 코디네이터가 컨슈머의 다운을 빠르게 감지하도록 설정해둔다면 일시적인 컨슈머의 타임아웃이나 일시적인 TCP 패킷 손실로 인해 원하지 않은 리밸런싱이 빈번하게 일어나는 현상이 발생할 수도 있습니다. 반대로 그룹 코디네이터가 컨슈머 다운을 늦게 감지하도록 설정해두면 그 시간만큼 해당 파티션의 메시지를 읽지 못하는 현상이 발생할 수도 있습니다.



# 6.3 스태틱 멤버십

하드웨어 점검이나 소프트웨어 업데이트 등의 이유로 관리자는 컨슈머 그룹 내의 컨슈머들을 하나씩 순차적으로 재시작하고 싶은 경우가 있을 것입니다. 하지만 하트비트 주기, 세션 타임아웃 등의 설정으로 인해 하나의 컨슈머가 재시작될 때마다 전체 리밸런싱이 일어나며 그 동안 컨슈머들은 일시 중지하므로 이는 매우 번거롭습니다. 10개의 컨슈머가 있다면 최소 10번 이상의 리밸런싱이 발생하고 10번 이상의 컨슈머 일시 중지가 일어납니다. 컨슈머의 재시작으로 인해 리밸런싱이 일어나는 배경을 알아보겠습니다. 일반적인 컨슈머 그룹 동작에서는 각 컨슈머를 식별하기 위해 엔티티 ID를 부여하게 됩니다. 이렇게 생성된 ID들은 컨슈머 그룹 내에서 임시로 사용되는 값입니다. 따라서 컨슈머의 설정 변경이나 소프트웨어 업데이트로 인해 컨슈머가 재시작되면, 컨슈머 그룹 내의 동일한 컨슈머임에도 새로운 컨슈머로 인식해 새로운 엔티티 ID가 부여되고 이로 인해 컨슈머 그룹의 리밸런싱이 발생하는 것입니다.

대용량 메시지들을 처리하는 컨슈머 그룹이라면 리밸런싱 동작으로 인해 원래 상태를 복구하는데 상당한 시간이 소요될 수 있습니다. 따라서 카프카는 이러한 불필요한 리밸런싱을 방어하기 위해 아파치 카프카 2.3버전부터 스태틱 멤버쉽이라는 개념을 도입했습니다. 스태틱 멤버쉽이란 컨슈머 그룹 내에서 컨슈머가 재시작 등으로 그룹을 나갔다가 다시 합류하더라도 리밸런싱이 일어나지 않게 합니다. 즉 컨슈머마다 인식할 수 있는 ID를 적용함으로써 다시 합류하더라도 그룹 코디네이터가 기존 구성원임을 인식할 수 있게 하는 것입니다. 그뿐 아니라 스태틱 멤버쉽 기능이 적용된 컨슈머는 그룹에서 떠날 때 그룹 코디네이터에게 알리지 않으므로 불필요한 리밸런싱도 발생하지 않습니다. 스태택 멤버쉽을 적용하기 위한 옵션은 간단합니다. 기본값이 null string인 group.instance.id만 설정하면 스태틱 멤버쉽이 적용합니다. 이 group.instance.id 옵션에는 그룹 코디네이터가 컨슈머를 식별하기 위해 컨슈머 인스턴스별로 고유한 값을 입력해야 합니다.

만약 스태택 멤버쉽 기능을 적용한다면 session.timeout.ms를 기본값보다는 큰 값으로 조정해야 합니다. 컨슈머의 재시작 시간이 총 2분 소요된다면 session.timeout.ms 값은 2분보다 큰 값으로 설정해야 불필요한 리밸랜싱 동작을 사전에 방지할 수 있습니다.



## 일반 컨슈머 그룹 실습

총 3대의 브로커에서 두 번의 컨슈머 그룹을 실행합니다. 첫 번째로 실행하는 컨슈머 그룹은 전형적인 일반 컨슈머 그룹입니다. 일반 컨슈머 그룹은 하나의 컨슈머가 종료되면 리밸런싱이 일어나야 합니다. 두 번째 컨슈머 그룹은 스태택 멤버쉽이 적용된 컨슈머 그룹입니다. 마찬가지로 컨슈머 하나를 강제 종료한 후 리밸런싱 동작이 일어나는지 확인해보겠습니다.

파이썬 3으로 작성된 컨슈머를 이용하기 때문에 각 브로커, peter-kafka01, 02, 03에 아래 명령어를 수행합니다.

```
sudo yum -y install python3
python3 -m venv venv6
source venv6/bin/activate
pip install confluent-kafka7
```



컨슈머 그룹 실습을 위해 토픽을 생성합니다. 토픽 이름은 peter-test06이고, 파티션 수는 3, 리플리케이션 팩터 수는 3으로 생성합니다. 

```
```



다시 모든 브로커에 접속해 다음 명령어로 깃을 설치하고 클론하여 consumer_standard.py를 실행합니다.

```
sudo yum -y install git
git clone https://github.com/onlybooks/kafka2.git
cd kafka2/chapter6/
python consumer_standard.py
```



이제 파이썬 코드로 작성된 프로듀서를 실행해보겠습니다. 프로듀서는 하나의 브로커에서 실행하면 됩니다. 가상환경을 켜고 producer를 실행합니다.

```
source venv6/bin/activate
python producer.py
```

```
```



카프카에서 제공하는 kafka-consumer-groups.sh 명령어를 이용해 컨슈머의 그룹의 상세보기를 확인해보겠습니다.

```
/usr/local/kafka/bin/kafka-consumer-groups.sh --bootstrap-server peter-kafka01.foo.bar:9092 --group peter-consumer01 --describe
```

```
```



결과를 확인해보니 peter-test06 토픽의 0,1,2 파티션이 각각 다른 consumer에 연결되었습니다. 이 상황에서 peter-kafka01의 컨슈머 프로세스를 강제종료하고 다시 컨슈머 그룹을 확인합니다.

``` 
/usr/local/kafka/bin/kafka-consumer-groups.sh --bootstrap-server peter-kafka01.foo.bar:9092 --group peter-consumer01 --describe
```

```
```



브로커 peter-kafka01의 컨슈머가 peter-consumer01 그룹에서 떠나자 그룹 코디네이터는 이 상황을 인지했으며 컨슈머 그룹 내부적으로 리밸랜싱이 일어났습니다.

파티션 수보다 컨슈머 수가 작기 때문에 브로커 peter-kafka03에서 실행 중인 컨슈머가 2개의 파티션을 담당하게 되었습니다. 또한 peter-kafka02의 컨슈머가 담당하고 있던 파티션도 변경되었습니다. 이처럼 컨슈머의 리밸런싱은 재시작되거나 그룹에서 떠나는 컨슈머만 대상으로 동작하는 것이 아니라, 컨슈머 그룹 내 전체 컨슈머를 대상으로 동작합니다. 컨슈머 리밸런싱 동작 과정 중 일시적으로 모든 컨슈머가 일시 중지하게 되는데, 대량의 메시지를 컨슘하는 컨슈머 그룹에게 이러한 일시 중지 동작은 매우 부담이 크며 고비용이 드는 작업입니다. 따라서 불필요한 리밸런싱은 최대한 줄여야 합니다.



## 스태틱 멤버십 컨슈머 그룹 실습

실습에서 이용할 스태틱 컨슈머인 consumer_static.py에는 다음과 같은 설정이 추가되어 있습니다.

``` python
hostname = socket.gethostname()
broker = 'peter-kafka01.foo.bar'
group = 'peter-consumer02'
topic = 'peter-test06'

c = Consumer({
    'bootstrap.servers': broker,
    'group.id': group,
    'session.timeout.ms': 30000,
    'group.instance.id': 'consumer-' + hostname,
    'auto.offset.reset': 'earliest'
})
```



이제 모든 브로커에서 스태틱 멤버십 설정이 적용된 컨슈머를 실행합니다.

```
python consumer_static.py
```



이제 컨슈머 그룹의 상세보기를 확인해보겠습니다.

``` 
/usr/local/kafka/bin/kafka-consumer-groups.sh --bootstrap-server peter-kafka01.foo.bar:9092 --group peter-consumer02 --describe
```

```
```



이제 브로커 peter-kafka01에서 실행 중인 컨슈머 프로세스를 강제 종료하고 해당 컨슈머 그룹의 상세보기를 확인해보겠습니다.

```
/usr/local/kafka/bin/kafka-consumer-groups.sh --bootstrap-server peter-kafka01.foo.bar:9092 --group peter-consumer02 --describe
```

```
```

브로커 peter-kafka01의 컨슈머 프로세스를 종료했음에도 불구하고 변경된 내용이 없습니다. 즉 리밸런싱이 일어나지 않았습니다. 하지만 앞서 설정한 sessoin.timeout.ms 값이 지난 뒤 다시 확인하면 새로운 파티션에 할당됐음을 알 수 있습니다.

```
/usr/local/kafka/bin/kafka-consumer-groups.sh --bootstrap-server peter-kafka01.foo.bar:9092 --group peter-consumer02 --describe
```

```
```



### 정리

표준 컨슈머를 사용하는 경우 컨슈머의 오류가 발생해 해당 컨슈머를 잠시 제거하고, 오류 수정 후 다시 컨슈머 그룹에 합류하면 총 두 번의 리밸런싱이 발생합니다. 하지만 스태틱 멤버십을 적용한 컨슈머를 활용하는 경우에는 session.timeout.ms에 지정된 시간을 넘어가지 않는다면 컨슈머를 잠시 제외하더라도 리밸런싱 동작이 발생하지 않게 됩니다.



# 6.4 컨슈머 파티션 할당 전략

프로듀서의 파티셔너는 레코드를 토픽의 어느 파티션으로 전송할지를 결정하는 역할을 했습니다. 컨슈머의 동작에서도 이와 유사하게 대상 토픽의 어느 파티션으로부터 레코드를 읽어올지를 결정합니다. 파티션 할당 전략은 컨슈머의 옵션의 partition-assignment-strategy로 표시하며, 총 네 가지를 제공합니다.

| 파티션 할당 전략               | 설명                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| 레인지 파티션 할당 전략        | 파티션 할당 전략의 기본값으로서 토픽별로 할당 전략을 사용함. 동일한 키를 이용하는 2개 이상의 토픽을 컨슘할 때 유용함 |
| 라운드 로빈 파티션 할당 전략   | 사용 가능한 파티션과 컨슈머들을 라운드 로빈으로 할당함. 균등한 분배 가능 |
| 스티키 파티션 할당 전략        | 컨슈머가 컨슘하고 있는 파티션을 계속 유지할 수 있음          |
| 협력적 스티키 파티션 할당 전략 | 스티키 방식과 유사하지만, 전체 일시 정지가 아닌 연속적인 재조정 방식임 |



## 6.4.1 레인지 파티션 할당 전략

레인지 파티션 할당 전략인 RangeAssignor는 파티션 할당 전략 중 기본값으로서, 각 토픽별로 할당 전략을 사용하게 됩니다. 레인지 파티션 할당 전략은 먼저 구독하는 토픽에 대한 파티션을 순서대로 나열한 후 컨슈머를 순서대로 정렬합니다. 그런 다음 각 컨슈머가 몇 개의 파티션을 할당해야 하는지 전테 파티션 수를 컨슈머 수로 나눕니다. 컨슈머 수와 파티션 수가 일치하면 균등하게 할당될 수 있지만 균등하게 나눠지지 않는 경우에는 앞쪽의 컨슈머들은 추가 파티션을 할당받게 됩니다.



### 예시

* 컨슈머1, 2가 있는 컨슈머 그룹
* 토픽1, 2
    * 각 토픽은 3개의 파티션으로 구성



1. 파티션을 0, 1, 2 순서대로 정렬
2. 컨슈머를 1, 2 순서대로 정렬
3. 파티션 수(3)를 컨슈머 수(2)로 나눔
4. 각 컨슈머에 파티션 하나씩 할당
5. 균등하게 나눠지지 않았으므로 컨슈머 1에 남은 파티션 할당



이처럼 불균형하게 할당되는 레인지 파티션 할당 전략을 왜 이용할까요?  레인지 파티션 할당 전략은 동일한 레코드 키를 사용하고 하나의 컨슈머 그룹이 동일한 파티션 수를 가진 2개 이상의 토픽을 컨슘할 때 유용할 수 있습니다. 예를 들어 토픽1의 0번 파티션은 프로듀서가 보내는 레코드의 키값 abc에 의해 기록되고 토픽2의 0번 파티션 역시 프로듀서가 보내는 레코드의 키값 abc에 의해 기록됩니다. 레인지 파티션 할당 전략에서는 컨슈머1에 토픽1의 0번 파티션과 토픽2의 0번 파티션이 동시에 할당되어 두 토픽의 0번 파티션을 컨슈머1이 모두 컨슘하게 됩니다. 결과적으로, 동일한 키값 abc를 갖고 있는 두 토픽의 파티션을 하나의 컨슈머가 컨슘하는 것입니다.



## 6.4.2 라운드 로빈 파티션 할당 전략

파티션과 컨슈머를 나열한 후 라운드 로빈으로 하나씩 파티션과 컨슈머를 할당하는 전략입니다.

### 예시

* 컨슈머, 토픽, 파티션 조건은 위와 동일

1. 토픽1-파티션0을 컨슈머1에 할당
2. 토픽1-파티션1을 컨슈머2에 할당
3. 토픽1-파티션2을 컨슈머1에 할당
4. 토픽2-파티션0을 컨슈머2에 할당
5. 토픽2-파티션1을 컨슈머1에 할당
6. 토픽2-파티션2을 컨슈머2에 할당



레인지 파티션 할당 전략에 비해 라운드 로빈 파티션 할당 전략 쪽이 파티션과 컨슈머를 더욱 균등하게 매핑합니다.



## 6.4.3 스티키 파티션 할당 전략

컨슈머 그룹의 리밸런싱 동작으로 인해 파티션이 재할당된다면 위 두 가지 방식 모두 기존에 매핑됐던 파티션과 동일한 컨슈머가 다시 매핑되리라고는 보장할 수 없습니다. 이러한 재할당 작업이 발생하더라도 기존에 매핑했던 파티션과 컨슈머를 최대한 유지하려고 하는 전략이 바로 스티키 파티션 할당 전략입니다.

스티키 파티션 할당 전략은 두 가지 목적으로 컨슈머에 파티션을 할당합니다.

* 가능한 한 균형 잡힌 파티션 할당
* 재할당이 발생할 때 되도록 기존의 할당된 파티션 정보를 보장

둘 중에 첫 번째 목적의 우선순위가 더 높습니다. 



리밸런싱이 일어나기 전에는 라운드 로빈 할당 전략과 유사합니다. 하지만 리밸런싱 후에는 확연한 차이를 보입니다.

### 예시

* 컨슈머1, 2, 3가 있는 컨슈머 그룹
* 토픽1, 2, 3, 4
    * 각 토픽은 2개의 파티션으로 구성



리밸런싱 전에는 아래와 같이 할당됩니다.

1. 토픽1-파티션0을 컨슈머1에 할당
2. 토픽1-파티션1을 컨슈머2에 할당
3. 토픽2-파티션0을 컨슈머3에 할당
4. 토픽2-파티션1을 컨슈머1에 할당
5. 토픽3-파티션0을 컨슈머2에 할당
6. 토픽3-파티션1을 컨슈머3에 할당
7. 토픽4-파티션0을 컨슈머1에 할당
8. 토픽4-파티션1을 컨슈머2에 할당



컨슈머 2가 컨슈머 그룹에서 떠나면 라운드 로빈 방식은 아래와 같이 재할당합니다. 이 경우 많은 파티션들이 본래의 컨슈머가 아닌 다른 컨슈머와 연결을 맺을 가능성이 높습니다.

1. 토픽1-파티션0을 컨슈머1에 할당
2. 토픽1-파티션1을 컨슈머3에 할당
3. 토픽2-파티션0을 컨슈머1에 할당
4. 토픽2-파티션1을 컨슈머3에 할당
5. 토픽3-파티션0을 컨슈머1에 할당
6. 토픽3-파티션1을 컨슈머3에 할당
7. 토픽4-파티션0을 컨슈머1에 할당
8. 토픽4-파티션1을 컨슈머3에 할당



컨슈머가 2가 컨슈머 그룹에서 떠났을 때 스티키 파티션 할당 전략은 아래와 같이 재할당합니다. 결과를 보면 기존 컨슈머 1과 컨슈머 3에 할당됐던 파티션들은 모두 유지한 채, 컨슈머 2에 할당된 파티션들만 나눠졌습니다.

1. 토픽1-파티션0을 컨슈머1에 할당
2. 토픽1-파티션1을 컨슈머3에 할당
3. 토픽2-파티션0을 컨슈머3에 할당
4. 토픽2-파티션1을 컨슈머1에 할당
5. 토픽3-파티션0을 컨슈머1에 할당
6. 토픽3-파티션1을 컨슈머3에 할당
7. 토픽4-파티션0을 컨슈머1에 할당
8. 토픽4-파티션1을 컨슈머3에 할당



스티키 파티션 할당 전략이 이렇게 이상적으로 동작하는 이유는 아래 규칙에 따라 재할당 동작을 수행하기 때문입니다.

* 컨슈머들의 최대 할당된 파티션 수의 차이는 1
* 기존에 존재하는 파티션 할당은 최대한 유지함
* 재할당 동작 시 유효하지 않은 모든 파티션 할당은 제거함
* 할당되지 않은 파티션들은 균형을 맞추는 방법으로 컨슈머들에 할당



## 6.4.4 협력적 스티키 파티션 할당 전략

협력적 스티키 파티션 할당 전략은 결과적으로 본다면 방금 설명한 스티키 전략과 동일한 방식입니다. 즉 리밸런싱이 일어나도 기존의 컨슈머와 파티션 매핑은 유지하고 최소한의 파티션만 컨슈머와 매핑합니다. 다만 협력적 스티키 파티션 할당 전략과 한 가지 차이점이 있는데, 바로 컨슈머 그룹 내부의 리밸런싱 동작이 한층 더 고도화됐다는 점입니다.

지금까지의 컨슈머 리밸런싱 동작에서는 내부적으로 EAGER라는 리밸런스 프로토콜을 사용했고, EAGER 프로토콜은 컨슈머 리밸런싱 동작 시 컨슈머에 할당된 모든 파티션을 항상 취소했습니다. 이렇게 리밸런싱 동작에서 모든 파티션을 항상 취소하는 이유로는 다음과 같이 두 가지를 꼽을 수 있습니다.

첫째로, 컨슈머들의 파티션 소유 변경 때문입니다. 예를 들어 A 컨슈머가 갖고 있는 0번 파티션의 소유권을 B 컨슈머에게 할당해야 하는 경우를 생각해봅시다. 하지만 하나의 컨슈머 그룹 내에서는 둘 이상의 컨슈머가 동일한 파티션을 소유할 수 없으므로 0번 파티션의 소유권을 B 컨슈머에게 넘길 수 없습니다. 결국 0번 파티션의 소유권을 넘기려면 0번 파티션에 대해 어떤 컨슈머도 소유권을 갖고 있어서는 안 됩니다. 둘째로 그룹 내에서 여러 파티션들에 대해 소유권 변경 작업이 동시에 이뤄져야 하므로 이러한 로직을 단순하게 구현하기 위해서입니다.

이렇게 리밸런싱 동작에서 컨슈머에 할당된 모든 파티션을 취소했으므로 컨슈머 그룹 전체에서 컨슈머와 파티션 재할당이 가능했고 한 번의 리밸런싱 동작으로 모든 컨슈머와 파티션 매핑을 할 수 있었습니다. 하지만 리밸런싱에서 모든 파티션 할당을 취소하는 동작은 리소스를 많이 사용하는 컨슈머 그룹에서는 큰 문제가 됩니다. 바로 컨슈머들의 다운타임입니다.

컨슈머의 다운타임이란  컨슈머에 할당된 모든 파티션을 취소한 상황을 말합니다. 프로듀서는 이와 별개로 지속적으로 메시지를 전송하고, 컨슈머의 다운타임 동안 LAG이 급격하게 증가합니다. 컨슈머의 다운타임은 특히 대량의 메시지를 컨슘하는 경우에 매우 큰 부담이 됩니다.

협럭적 스티키는 내부 리밸런싱 프로토콜인 EAGER가 아닌 COOPERATIVE(협력적) 프로토콜을 적용하기 시작했고, 이 프로토콜은 리밸런싱이 동작하기 전의 컨슈머 상태를 유지할 수 있게 했습니다.

기존의 리밸런싱 동작은 한 번에 모든 파티션 할당 작업이 끝난다는 장점이 있지만 전체 컨슈머가 일시적으로 멈춘 상태에서 리밸런싱이 이뤄진다는 제약이 있습니다. 하지만 새로운 방식인 협럭적 스티키 할당 전략에서는 되도록 동작 중인 컨슈머들에게 영향을 주지 않는 상태에서 몇 차례에 걸쳐 리밸런싱이 이뤄집니다. 



### 예시

peter-consumer01 컨슈머 그룹에 peter-kafka02, peter-kafka03이라는 2개의 컨슈머가 3개의 파티션을 컨슘하고 있는 상태에서 새로운 컨슈머(peter-kafka01)가 합류하면서 리밸런싱이 일어나는 과정을 볼 수 있습니다.

1. 컨슈머 그룹에 peter-kafka01이 합류하면서 리밸런싱이 트리거됩니다. (감지 단계)
2. 컨슈머 그룹 내 컨슈머들은 그룹 합류 요청과 자신들의 컨슘하는 토픽의 파티션 정보를 그룹 코디네이터로 전송합니다. (감지 단계)
3. 그룹 코디네이터는 해당 정보를 조합해 컨슈머 그룹의 리더에게 전송합니다. (감지 단계)
4. 컨슈머 그룹의 리더는 현재 컨슈머들이 소유한 파티션 정보를 활용해 제외해야 할 파티션 정보를 담은 새로운 파티션 할당 정보를 컨슈머 그룹 멤버들에게 전달합니다. (첫 번째 리밸런싱 단계)
5. 새로운 파티션 할당 정보를 받은 컨슈머 그룹 멤버들은 현재 파티션 할당 전략과 차이를 비교해보고 필요 없는 파티션을 골라 제외합니다. 이전의 파티션 할당 정보와 새로운 파티션 할당 정보가 동일한 파티션들에 대해서는 어떤 작업도 수행할 필요가 없습니다. (첫 번째 리밸런싱 단계)
6. 제외된 파티션 할당을 위해 컨슈머들은 다시 합류 요청을 합니다. (두 번째 리밸런싱 단계)
7. 컨슈머 그룹의 리더는 제외된 파티션을 적절항 컨슈머에게 할당합니다. (두 번째 리밸런싱 단계)



위에서 봤듯이 협력적 스티키 파티션 할당 전략에서 중요한 점은 파티션 재배치가 필요하지 않은 컨슈머들은 다운타임 없이 계속 동작하며, 한 번이 아니라 두 차례의 리밸런싱이 일어났다는 점입니다.

첫 번째 리밸런싱 동작에서는 peter-kafka02가 소유하고 있던 2번 파티션만 제외됐고, 두 번째 리밸런싱 동작에서는 제외된 2번 파티션이 새로운 peter-kafka01 컨슈머에게 새롭게 할당됐습니다.



# 6.5 정확히 한 번 컨슈머 동작

트랜잭션 코디네이터는 프로듀서의 정확히 한 번 전송이 성공하면 해당 레코드의 트랜잭션 성공을 표시하는 특수한 메시지를 추가합니다. 따라서 컨슈머는 트랜잭션 코디네이터가 특수한 메시지를 표시한 레코드만 읽는다면, 정확히 한 번 읽을 수 있습니다. 

### 

### 트랜잭션 컨슈머 예제 코드

``` java
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;

import java.util.Arrays;
import java.util.Properties;

public class ExactlyOnceConsumer {
    public static void main(String[] args) {
        String bootstrapServers = "peter-kafka01.foo.bar:9092";
        Properties props = new Properties();
        props.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        props.setProperty(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
        props.setProperty(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
        props.setProperty(ConsumerConfig.GROUP_ID_CONFIG, "peter-consumer-01");
        props.setProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        props.setProperty(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, "false");
        props.setProperty(ConsumerConfig.ISOLATION_LEVEL_CONFIG, "read_committed"); // 정확히 한번 전송을 위한 설정

        KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);
        consumer.subscribe(Arrays.asList("peter-test05"));

        try {
            while (true) {
                ConsumerRecords<String, String> records = consumer.poll(1000);
                for (ConsumerRecord<String, String> record : records) {
                    System.out.printf("Topic: %s, Partition: %s, Offset: %d, Key: %s, Value: %s\n",
                            record.topic(), record.partition(), record.offset(), record.key(), record.value());
                }
                consumer.commitAsync();
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            consumer.close();
        }
    }
}
```



일반 컨슈머 코드에서 ISOLATION_LEVEL_CONFIG라는 설정만 추가하면 트랜잭션 컨슈머로 동작합니다. 트랜잭션 컨슈머는 트랜잭션 코디네이터와 통신하는 부분은 없으며 트랜잭션이 완료된 메시지만 읽을 수 있습니다. 기본값은 read_uncommitted로서 모든 메시지를 읽을 수 있다는 뜻이며, read_committed로 옵션값을 변경하면 트랜잭션이 완료된 메시지만 읽을 수 있게 됩니다.

5장에서 peter-test05 토픽에 트랜잭션 프로듀서를 이용해 메시지 전송이 완료된 상태입니다. 이제 위 트랜잭션 컨슈머 자바 코드를 이용해 메시지를 읽어보겠습니다. peter-ansible01 서버에 접속한 후 kafka2/chapter6 경로로 이동합니다.



이제 JAR 파일을 이용해 실행되면 컨슈머 관련 옵션들이 출력될 것이고 성공적으로 메시지를 읽었다면 다음과 같이 표시될 것입니다.

```
cd kafka2/chapter6/
java -jar ExactlyOnceConsumer.jar
```

```
```



이와 같이 컨슈머가 실행된 상태에서 트랜잭션 프로듀서를 이용해 메시지를 한 번 더 전송해보겠습니다.

``` 
cd kafka2/chapter5/
java -jar ExactlyOnceProducer.jar
```



컨슈머의 마지막 부분에 한 건의 메시지가 추가된 걸 확인할 수 있습니다.

```
```

분명 한 건의 메시지를 전송했는데 오프셋이 2로 표시되어 있습니다. 일반적인 전송이었다면 오프셋이 1이어야 합니다. 이렇게 오프셋이 하나 더 추가된 이유는 트랜잭션의 종료를 표시하기 위해 메시지 전송 후 커밋 또는 중단에 대한 표시를 남기는 트랜잭션 메시지가 추가되기 때문입니다.



컨슈머는 트랜잭션 코디네이터와 통신하는 부분이 없으므로 정확하게 메시지를 한 번 가져오는지는 보장할 수 없습니다. 

컨슈머의 동작까지 정확히 한 번 처리가 가능해지려면 '컨슘-메시지 처리-프로듀싱' 동작이 모두 하나의 트랜잭션으로 처리돼야 합니다. '컨슘-메시지 처리-프로듀싱'의 트랜잭션에서는 sendOffsetsToTransaction 메소드를 이용하며 컨슈머 그룹의 오프셋 커밋을 트랜잭션에 포함시킵니다. 만약 이 처리 과정에서 트랜잭션 실패가 발생하면, 해당 컨슈머 그룹의 커밋 오프셋이 증가하지 않게 함으로써 실패한 트랜잭션을 다시 시작할 수 있습니다.
