# 02. 몽고DB 기본

* 몽고DB 데이터의 기본 단위는 **도큐먼트**이며, 이는 관계형 데이터베이스의 행과 유사하다.
* **컬렉션**은 동적 스키마가 없는 테이블과 같다.
* 몽고DB의 단일 인스턴스는 자체적인 컬렉션을 갖는 여러 개의 독립적인 데이터베이스를 호스팅한다.
* 모든 도큐먼트는 컬렉션 내에서 고유한 특수키인 "_id"를 가진다.
* 몽고DB는 **몽고 쉘**이라는 간단하지만 강력한 도구와 함께 배포된다. 몽고 쉘은 몽고DB 인스턴스를 관리하고 몽고 DB 쿼리 언어로 데이터를 조작하기 위한 내장 지원을 제공한다.
    또한 사용자가 다양한 목적으로 자신의 스크립트를 만들고 로드할 수 있는 완전한 기능의 자바스크립트 interpreter이다.



## 2.1 도큐먼트

몽고DB의 핵심은 정렬된 키와 연결된 값의 집합으로 이뤄진 **도큐먼트**다. 도큐먼트 표현 방식은 프로그래밍 언어마다 다르지만 대부분의 언어는 map, hash, dictionary와 같이 도큐먼트를 자연스럽게 표현하는 자료구조를 가진다.

도큐먼트의 키는 문자열이다. 예외 몇 가지를 제외하면 어떤 UTF-8 문자든 쓸 수 있다.

* 키는 \0(null)을 포함하지 않는다. null은 키의 끝을 나타내는 데 사용된다.
* .과 $ 문자는 몇 가지 특별한 속성을 가진 예약어이다.



몽고DB는 데이터형과 대소문자를 구별하기 때문에 아래 두 도큐먼트는 서로 다릅니다.

``` 
{"count": 5}
{"count": "5"}
```

```
{"count": 5}
{"Count": 5}
```



또한 도큐먼트는 키가 중복될 수 없다.



## 2.2 컬렉션

**컬렉션**은 도큐먼트의 모음이다. 위에서 말했듯이 테이블에 대응되는 개념이다.



### 2.2.1 동적 스키마

컬렉션은 **동적 스키마**를 가진다. 동적 스키마를 가진다는 말은 하나의 컬렉션 내 도큐먼트들이 모두 다른 구조를 가질 수 있다는 의미다. 예를 들어 다음 도큐먼트들은 하나의 컬렉션에 저장할 수 있다.

``` 
{"A": "hello", "B": 3}
{"C": "mongoDB"}
```



도큐먼트들의 키, 키의 개수, 데이터형의 값은 모두 다르다. 다른 구조의 도큐먼트라도 같은 컬렉션에 저장할 수 있는데 '왜 별도의 컬렉션이 필요하지?'라고 생각할 수 있다. 도큐먼트에 별도의 스키마가 필요 없는데 왜 하나 이상의 컬렉션이 필요할까?

* 같은 컬렉션에 다른 종류의 도큐먼트를 저장하면 개발자와 관리자에게 번거로운 일이 생길 수도 있다. 각 쿼리가 특정 스키마를 고수하는 도큐먼트를 반환하는지, 혹은 쿼리한 코드가 다른 구조의 도큐먼트를 다룰 수 있는지 확실히 확인하자. 예를 들어 블로그 게시물을 쿼리한 데이터 중 작성자 데이터만 제거하려면 상당히 번거롭다.
* 컬렉션별로 목록을 뽑으면 한 컬렉션 내 특정 데이터형별로 쿼리해서 목록을 뽑을 때마다 훨씬 빠르다. 예를 들어 "요약", "전체", "뚱뚱이 원숭이"와 같은 컬렉션형을 값으로 하는 "type"키가 도큐먼트 내에 있다면, 단일 컬렉션에 들어 있는 값을 찾기보다 세 컬렉션 중에서 올바른 컬렉션을 쿼리하는 편이 훨씬 빠르다.
* 같은 종류의 데이터를 하나의 컬렉션에 모아두면 데이터 지역성에도 좋다. 블로그 게시물 여러 개를 뽑는 경우, 게시물과 저자 정보가 섞인 컬렉션보다 게시물만 들어 있는 컬렉션에서 뽑을 때 디스크 탐색 시간이 더 짧다.
* 인덱스를 만들면 도큐먼트는 특정 구조를 가져야 한다. 이러한 인덱스는 컬렉션별로 정의한다.



애플리케이션 스키마는 기본적으로 필요하지는 않지만 정의하면 좋다. 몽고DB의 도큐먼트 유효성 검사 기능과 객체-도큐먼트 매핑 라이브러리를 이용하며, 이는 많은 프로그래밍 언어에서 사용 가능하다.



### 2.2.2 네이밍

컬렉션은 이름으로 식별된다. 어떤 UTF-8 문자도 쓸 수 있지만 몇 가지 제약조건이 있다.

* 빈 문자열은 유효한 컬렉션명이 아니다.
* \0(null)은 컬렉션명의 끝을 나타내는 문자이므로 컬렉션명에 사용할 수 없다.
* system. 으로 시작하는 컬렉션 명은 예약어이다.
* 사용자가 만든 컬렉션은 이름에 예약어인 $를 포함할 수 없다.



#### 서브컬렉션

서브컬렉션의 네임스페이스에 . 문자를 사용해 컬렉션을 체계화한다. 예를 들어 블로그 기능이 있는 애플리케이션은 blog.posts와 blog.authors라는 컬렉션을 가질 수 있다. 이는 단지 체계화를 위함이며 blog 컬렉션이나 자식 컬렉션과는 아무런 관계가 없다.





## 2.3 데이터베이스

몽고DB는 컬렉션에 도큐먼트를 그룹화할 뿐 아니라 데이터베이스에 컬렉션을 그룹 지어 놓는다. 몽고DB의 단일 인스턴스는 여러 데이터베이스를 호스팅할 수 있으며, 각 데이터베이스를 완전히 독립적으로 취급할 수 있다. 한 애플리케이션의 데이터를 동일한 데이터베이스에 저장하는 것은 좋은 방식이다. 데이터베이스를 나누면 하나의 몽고DB 서버에서 여러 애플리케이션이나 여러 사용자 데이터를 저장할 때 유용하다.

데이터베이스는 이름으로 식별되며 어떤 UTF-8 문자열이든 쓸 수 있지만 몇 가지 제약 조건이 있다.

* 빈 문자열은 유효한 데이터베이스 명이 아니다.
* 데이터베이스 이름은 다음 문자를 포함할 수 없다. 
    * / \ . ' ' * < > : | ? $ \0
* 데이터베이스 이름은 대소문자를 구별한다.
* 데이터베이스 이름은 최대 64바이트다.



#### 예약된 데이터베이스

* admin : 인증과 권한부여 역할을 한다.
* local : 단일 서버에 대한 데이터를 저장한다. replica set에서 local은 replication 프로세스에 사용된 데이터를 저장한다.
* config : sharding된 몽고DB 클러스터는 config 데이터베이스를 사용해 갹 shard의 정보를 저장한다.



## 2.4 몽고DB 시작

### 몽고DB 설치

몽고DB를 설치한다.

``` 
brew install mongodb-community
```



몽고DB를 실행한다.  몽고DB는 기본적으로 27017번 포트에서 소켓 연결을 기다린다.

```
brew services start mongodb-community
```



몽고DB를 비활성화한다.

```
brew services stop mongodb-community
```



## 2.5 몽고DB 셸 소개

셸은 관리 기느이나 실행 중인 인스턴스를 점검하거나 간단한 기능을 시험하는 데 매우 유용하다.



### 2.5.1 셸 실행

mongo를 실행해 셸을 시작한다.

```
❯ mongo
MongoDB shell version v5.0.6
connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&gssapiServiceName=mongodb
```



셸은 완전한 자바스크립트 해석기이므로 표준 자바스크립트 라이브러리의 모든 기능을 활용할 수 있다.



### 2.5.2 몽고DB 클라이언트

셸은 시작할 때 몽고DB 서버의 test 데이터베이스에 연결하고, 데이터베이스 연결을 전역변수 db에 할당한다.

현재 db에 할당된 데이터베이스를 확인하려면 db를 입력한다.

```
> db
test
```



데이터베이스를 선택할 수 있다.

```
> use video
switched to db video
```

```
> db
video
```



db 변수에서 컬렉션에 접근하면 현재 데이터베이스의 movies 컬렉션을 반환한다.

```
> db.movies
video.movies
```



### 2.5.3 셸 기본 작업

#### 생성

insertOne 함수는 컬렉션에 도큐먼트를 추가한다.

```
> movie = {"title": "A", "year": 1977}
{ "title" : "A", "year" : 1977 }

> db.movies.insertOne(movie)
{
	"acknowledged" : true,
	"insertedId" : ObjectId("6235740dfdf05620d30f86c7")
}
```



#### 읽기

find와 findOne은 컬렉션을 쿼리하는 데 사용한다.

``` 
> db.movies.findOne()
{
	"_id" : ObjectId("6235740dfdf05620d30f86c7"),
	"title" : "A",
	"year" : 1977
}
```



쿼리 도큐먼트 형태로 조건 전달도 가능하다.



#### 갱신

갱신하려면 updateOne을 사용한다. updateOne의 매개변수는 최소 두 개다.

* 수정할 도큐먼트 찾는 기준
* 갱신 작업을 설명하는 도큐먼트

갱신하려면 갱신 연산자 set을 이용한다.
도큐먼트에 "reviews"키가 생긴 것을 확인할 수 있다.

```
> db.movies.updateOne({"title": "A"}, {$set: {reviews: []}})
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

> db.movies.find().pretty()
{
	"_id" : ObjectId("6235740dfdf05620d30f86c7"),
	"title" : "A",
	"year" : 1977,
	"reviews" : [ ]
}
```



#### 삭제

deleteOne과 deleteMany는 도큐먼트를 영구적으로 삭제한다.

``` 
> db.movies.deleteOne({"title": "A"})
```



## 2.6 데이터형

### 2.6.1 기본 데이터형

몽고DB는 JSON의 key/value 쌍 성질을 유지하면서 추가적인 데이터형을 지원한다. 



#### null

존재하지 않는 필드를 표현하는데 사용한다.

```
{"x": null}
```



#### boolean

참과 거짓 값에 사용한다.

```
{"x": true}
```



#### 숫자

64비트 부동소수점 수를 기본으로 사용한다.
4바이트 혹은 8바이트 signed integer는 각각 NumberInt, NumberLong 클래스를 사용한다.

```
{"x": 3.14}
{"x": NumberInt("3")}
{"x": NumberLong("3")}
```



#### 문자열

```
{"x": "foobar"}
```



#### 날짜

1970년 1월 1일부터의 시간을 1/1000초 단위로 나타내는 64비트 정수로 날짜를 저장한다.
표준시간대는 저장하지 않는다.

```
{"x": new Date()}
```



#### 정규 표현식

쿼리는 자바스크립트 정규 표현식 문법을 사용할 수 있다.



#### 배열

값의 set이나 리스트를 배열로 표현할 수 있다.

```
{"x": ["a", "b", "c"]}
```



#### 내장 도큐먼트

```
{"x": {"foo": "bar"}}
```



#### 객체 ID

객체 ID는 도큐먼트용 12바이트 ID다.

```
{"x": ObjectId()}
```



#### 이진 데이터

이진 데이터는 임의의 바이트 문자열이며 셸에서는 조작이 불가능하다. 이진 데이터는 데이터베이스에 UTF-8이 아닌 문자열을 저장하는 유일한 방법이다.



#### 코드

쿼리와 도큐먼트는 임의의 자바스크립트 코드를 포함할 수 있다.

``` 
{"x": function() { /*...*/ }}
```



### 2.6.2 날짜

자바스크립트에서 Date클래스는 몽고DB의 날짜를 표현하는 데 사용한다. 새로운 Date 객체를 생성할 때는 항상 Date()가 아닌 new Date()를 호출해야 한다. 그렇지 않으면 실제 Date 객체가 아닌 날짜의 문자열 표현을 반환한다.



### 2.6.3 배열

배열은 정렬 연산(list, stack, queue)과 비정렬 연산(set)에 호환성 있게 사용 가능한 값이다. 
배열은 서로 다른 데이터형을 값으로 포함할 수 있으며 중첩 배열도 가능하다.



### 2.6.4 내장 도큐먼트

도큐먼트는 키에 대한 값이 될 수 있는데 이를 내장 도큐먼트라고 한다.

``` 
{
    "name": "John",
    "adddress": {
        "street": "123 Park Street",
        "city": "Anytown"
    }
}
```



RDB에서는 이 도큐먼트가 두 개의 테이블에 분리된 두 개의 행으로 모델링된다. 몽고DB에서는 "people" 도큐먼트 내에 바로 "address" 도큐먼트를 내장한다.

하지만 몽고DB에서는 더 많은 데이터 반복이 생길 수 있다는 단점이 있다. address가 수정되면 각 사람의 도큐먼트에서 모두 고쳐야한다.



### 2.6.5 _id와 ObjectId

몽고DB에 저장된 모든 도큐먼트는 `_id` 키를 가진다. `_id`키 값은 어떤 데이터형이어도 상관없지만 ObjectId가 기본이다. 하나의 컬렉션에서 모든 도큐먼트는 고유한 `_id`값을 가지며 이 값은 컬렉션 내 모든 도큐먼트가 고유하게 식별되게 한다.



#### ObjectId

자동 증가하는 기본 키처럼 전통적인 것이 아닌 ObjectId를 사용하는 주요 이유는 몽고DB의 분산 특성 때문이다. 몽고DB는 분산 데이터베이스로 설계됐기 때문에 샤딩된 환경에서 고유 식별자를 생성하는 것이 매우 중요했다.

ObjectId는 12바이트 스토리지를 사용하며 24자리 16진수 문자열 표현이 가능하다. 바이트당 2자리를 사용한다. ObjectId가 흔히 거대한 16진수 문자열로 표현되긴 하지만 실제로 문자열은 저장된 데이터의 두 배만큼 길다.



ObjectId의 앞 12바이트는 타임스탬프, 랜덤, 카운트로 구성된다.

##### 타임스탬프

첫 4바이트는 1970년 1월 1일부터의 시간을 1/1000초 단위로 저장하는 타임스탬프다. 타임스탬프를 저장함으로서 몇 가지 유용한 속성을 제공한다.

* 타임스탬프는 그 다음 5바이트와 묶일 때 초 단위의 유일성을 제공한다.
* 타임스탬프가 맨 처음에 온다는 것은 ObjectId가 대략 입력 순서대로 정렬된다는 의미다. 



##### 랜덤, 카운트

다음 5바이트는 랜덤 값이다.  최종 3바이트는 서로 다른 시스템에서 충돌하는 ObjectId들을 생성하지 않도록 랜덤 값으로 시작하는 카운터다.



ObjectId의 앞 9바이트는 1초 동안 여러 장비와 프로세스에 걸쳐 유일성을 보장한다. 마지막 3바이트는 단순히 증분하는 숫자로, 1초 내 단일 프로세스의 유일성을 보장한다.































